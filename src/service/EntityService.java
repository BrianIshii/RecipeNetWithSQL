package service;

import entity.Entity;
import formatter.Field;
import schema.RequestSchema;
import schema.ResponseSchema;

import java.util.List;

public abstract class EntityService {
  protected static ExecutorService executorService = ExecutorService.getInstance();

  /**
   * Based on the state of the entity being saved, may create, update, or delete the entity in the
   * database. This is the only way to interact with the database to ensure entities are being
   * persisted in a predictable manner.
   *
   * @param entity
   * @param <E>
   * @return
   */
  public <E extends Entity> E save(E entity) {
    switch (entity.getStatus()) {
      case NEW:
        return create(entity);
      case DIRTY:
        return commit(entity);
      case DELETED_LOCALLY:
        delete(entity);
        return null;
      case SYNCED:
      default:
        return entity;
    }
  }

  /**
   * Invokes the delete method of the ExecutorService, using the primary key of the provided Entity
   * to target the correct tuple.
   *
   * @param entity
   * @param <E>
   * @return
   */
  protected <E extends Entity> boolean delete(E entity) {
    List<Field> primaryFields = entity.getPrimaryKeys();
    return executorService.executeDelete(entity.getTableName(), primaryFields);
  }

  /**
   * Invokes the insert method of the ExecutorService to create a tuple in the database with the new
   * fields. The returned entity will have it's primary key populated with the id generated by the
   * database.
   *
   * @param entity
   * @param <E>
   * @return
   */
  protected <E extends Entity> E create(E entity) {
    RequestSchema primaryFields = new RequestSchema(entity.getPrimaryKeys());
    RequestSchema nonPrimaryFields = new RequestSchema(entity.getNonPrimaryKeys());
    ResponseSchema response =
            executorService.executeInsert(entity.getTableName(), primaryFields, nonPrimaryFields);
    if (response == null) return null;
    response.applyValuesTo(entity, true);
    entity.setSynced();
    return entity;
  }

  /**
   * Invokes the update method of the ExecutorService to update a row in the database. It extracts
   * and used the primary key to target the correct tuple.
   *
   * @param entity
   * @param <E>
   * @return
   */
  protected <E extends Entity> E commit(E entity) {
    RequestSchema primaryFields = new RequestSchema(entity.getPrimaryKeys());
    RequestSchema nonPrimaryFields = new RequestSchema(entity.getNonPrimaryKeys());
    boolean status =
            executorService.executeUpdate(entity.getTableName(), nonPrimaryFields, primaryFields);
    if (status) entity.setSynced();
    else
      throw new RuntimeException(String.format("Failed to update entity: %s", entity.toString()));
    return entity;
  }
}
